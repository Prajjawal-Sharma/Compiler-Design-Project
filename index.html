<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Parser Visualizer and Calculator
    </title>
    <link
      href="https://fonts.googleapis.com/css?family=Comfortaa:400,700"
      rel="stylesheet"
      type="text/css"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Comfortaa:400,700,400italic,700italic"
      rel="stylesheet"
      type="text/css"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="./styles.css" />
    
  </head>
  <body id="body">
    <nav class="navbar navbar-expand-lg bg-body-tertiary">
      <div class="container-fluid">
        <a class="navbar-brand" href="#body">Parser Visualizer and Calculator</a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarNav"
          aria-controls="navbarNav"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav">
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="#home" style="margin-left: 15rem">Index</a>
            </li>
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="#about">Introduction</a>
            </li>
            <li class="nav-item">
                <a class="nav-link active" aria-current="page" href="#types">Types of Parser</a>
              </li>
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="#app">Try Now!</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <header class="masthead bg-success text-white text-center">
      <div class="header_container" id="home">
        <img src="assets/aggregate.png" alt="no preview" height="500rem"/>
        <h1>Parser Visualizer</h1>
      </div>
    </header>
    <section class="about" id="about">
      <div class="about_content">
        <h1>Introduction to Parser</h1>
        <p>
          Parsing is the process of analyzing a sequence of characters or tokens to determine the grammatical structure of a sentence or programming language code. It involves breaking down a text or code into its constituent parts and organizing those parts into a structured representation that can be used for further analysis, such as evaluation or translation. It  involves analyzing the syntax of a code snippet or program to identify the structure of the program and to check for any syntax errors. This is often done using a parser, which is a program or algorithm that reads the code and generates a structured representation of it, such as a parse tree or abstract syntax tree. The parse tree or abstract syntax tree can then be used for further analysis, such as code optimization, type checking, or code generation. 
        </p> 
        <br />
        <p>
          There are two general approaches to parsing: top-down and bottom-up. Top-down parsing starts at the root of the parse tree and works its way down to the leaves, while bottom-up parsing starts at the leaves and works its way up to the root. Top-down parsing is often used in cases where the input language is simple and the grammar is not too complex. Bottom-up parsing is used when the grammar is more complex and the input language is more difficult to parse.

        In top-down parsing, the parser begins with the starting symbol of the grammar and tries to match the input against the rules of the grammar, moving from left to right. 

        While in bottom-up parsing, the parser starts with individual tokens and builds up the parse tree or AST by grouping tokens together according to the production rules of the grammar. 
        There are also other parsing techniques that combine elements of top-down and bottom-up parsing. For example, LL parsing is a top-down technique that uses a look-ahead symbol to predict the next production rule, while LALR parsing is a variant of LR parsing that uses a look-ahead LR(1) parser augmented with a merge operation to reduce the size of the parsing table.
        </p>
      </div>
      <div class="about_image">
        <img src="./assets/parsing.jpg" alt="no prev" />
      </div>
    </section>
    <section class="types_of_parsers" id="types">
      <h1 class="parser_header">Types of Parsers</h1>
      <div class="lalr">
        <div class="lalr_content">
          <h1>LR(1) Parser</h1>
          <p>
          LR(1) parser is a bottom-up parsing algorithm used in compiler design. It is a type of predictive parsing algorithm that uses a stack-based approach to parse the input string and build a parse tree.

          The "LR" in LR(1) stands for "left-to-right, rightmost derivation". This means that the algorithm works by constructing a rightmost derivation of the input string, starting from the leftmost symbol. The "1" in LR(1) refers to the fact that the algorithm looks ahead one symbol at a time in the input to make its predictions.

          LR(1) parser uses a state machine to keep track of the current state of the parsing process. The state machine is constructed using a set of LR(1) items, which are basically productions with a dot (.) symbol representing the current position in the production. Each LR(1) item is associated with a set of lookaheads, which are the symbols that may follow the current position of the dot in the production.

          The LR(1) parser starts with an initial state, which contains the LR(1) item for the start symbol of the grammar with the dot at the beginning of the production, and the lookahead symbol being the end-of-input symbol ($). The parser then uses a set of rules to determine the next state and action to take based on the current state and input symbol.

          The LR(1) parser uses a stack to keep track of the LR(1) items and lookaheads as it processes the input string. When the parser encounters a terminal symbol, it matches it with the current lookahead symbol on the stack and pops it off the stack. When the parser encounters a non-terminal symbol, it uses the current state and lookahead symbol to determine the next state and the set of LR(1) items to push onto the stack.

          If the LR(1) parser encounters a conflict during the parsing process, such as a shift-reduce or reduce-reduce conflict, it uses a set of precedence rules to resolve the conflict and determine the correct action to take.

          LR(1) parsers are more powerful than LL(1) parsers because they can handle any context-free grammar. However, they are also more complex to implement and may require more memory and processing time. In practice, LR(1) parsers are often used to parse large and complex programming languages because of their power and flexibility.
        </div>
        <div class="lalr_image">
            <img src="./assets/lalr1.jpg" alt="no prev">
        </div>
      </div>
      <div class="slr">
        <div class="slr_content">
          <h1>LL(1) Parser</h1>
          <p>
            LL(1) parser is a top-down parsing algorithm used in compiler design. It is a type of predictive parsing algorithm that uses a recursive descent approach to parse the input string and build a parse tree.

            The "LL" in LL(1) stands for "left-to-right, leftmost derivation". This means that the algorithm works by constructing a leftmost derivation of the input string, starting from the leftmost symbol. The "1" in LL(1) refers to the fact that the algorithm looks ahead one symbol at a time in the input to make its predictions.

          LL(1) parser uses a parsing table to determine the next production to use based on the current non-terminal symbol and lookahead symbol. The parsing table is constructed using a set of rules that specify the productions to use based on the current non-terminal symbol and lookahead symbol.

          The LL(1) parser starts with an initial state, which contains the start symbol of the grammar and the lookahead symbol being the first symbol of the input string. The parser then uses the parsing table to determine the next production to use based on the current non-terminal symbol and lookahead symbol.

          The LL(1) parser uses a stack to keep track of the non-terminal symbols and lookaheads as it processes the input string. When the parser encounters a terminal symbol, it matches it with the current lookahead symbol on the stack and pops it off the stack. When the parser encounters a non-terminal symbol, it uses the parsing table to determine the next production to use and the set of symbols to push onto the stack.

          If the LL(1) parser encounters a conflict during the parsing process, such as a predict set overlap, it cannot resolve the conflict using precedence rules. In this case, the grammar must be modified to remove the conflict or a more powerful parsing algorithm, such as an LR(1) parser, must be used.

          LL(1) parsers are simpler to implement than LR(1) parsers because they use a table-driven approach rather than a state machine. However, they are also less powerful than LR(1) parsers because they can only handle a restricted class of context-free grammars. In practice, LL(1) parsers are often used to parse simple programming languages or subsets of larger programming languages because of their simplicity and efficiency.
          </p>
        </div>
        <div class="slr_image">
            <img src="./assets/slr.png" alt="no prev">
        </div>
      </div>
    </section>
    <section class="try_the_app" id="app">
        <h1>Try The Visualizer!</h1>
        <div class="visual_routes">
            <a href="./lr1.html" target="_blank"><button class="lalr_btn"><img src="./assets/compiler.png"/>Try LR(1) Parser!</button></a>
            <a href="./ll1.html" target="_blank"><button class="slr_btn"><img src="./assets/website.png"/>Try LL(1) Parser!</button></a>
        </div>
    </section>
    
   
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.7/dist/umd/popper.min.js"
      integrity="sha384-zYPOMqeu1DAVkHiLqWBUTcbYfZ8osu1Nd6Z89ify25QV9guujx43ITvfi12/QExE"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.min.js"
      integrity="sha384-Y4oOpwW3duJdCWv5ly8SCFYWqFDsfob/3GkgExXKV4idmbt98QcxXYs9UoXAB7BZ"
      crossorigin="anonymous"
    ></script>
  </body>
</html>
